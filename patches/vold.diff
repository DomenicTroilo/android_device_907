diff --git a/system/vold/Android.mk b/system/vold/Android.mk
--- a/system/vold/Android.mk
+++ b/system/vold/Android.mk
@@ -14,6 +14,7 @@ common_src_files := \
        Ext4.cpp \
        Fat.cpp \
        Ntfs.cpp \
+       exFat.cpp \
        Loop.cpp \
        Devmapper.cpp \
        ResponseCode.cpp \
diff --git a/system/vold/exFat.cpp b/system/vold/exFat.cpp
--- a/system/vold/exFat.cpp
+++ b/system/vold/exFat.cpp
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/mount.h>
+
+#include <linux/kdev_t.h>
+
+#define LOG_TAG "Vold"
+
+#include <cutils/log.h>
+#include <cutils/properties.h>
+
+#include "Exfat.h"
+
+static char FSCK_EXFAT_PATH[] = "/system/bin/fsck.exfat";
+static char MK_EXFAT_PATH[] = "/system/bin/mkfs.exfat";
+static char MOUNT_EXFAT_PATH[]="/system/bin/mount.exfat";
+
+extern "C" int logwrap(int argc, const char **argv, int background);
+extern "C" int mount(const char *, const char *, const char *, unsigned long, const void *);
+
+int Exfat::check(const char *fsPath)
+{  
+	ALOGV("Exfat::check");
+	if (access(FSCK_EXFAT_PATH, X_OK)) {
+        ALOGW("Skipping fs checks\n");
+        return 0;
+    }
+
+    int rc = 0;
+
+    const char *args[5];
+    args[0] = FSCK_EXFAT_PATH;   
+    args[1] = fsPath;
+    args[2] = NULL;
+
+    rc = logwrap(2, args, 1);
+	if( rc != 0 )
+	{	
+       ALOGE("Filesystem check failed (unknown exit code %d)", rc);
+    }
+
+	return rc;
+}
+
+int Exfat::doMount(const char *fsPath, const char *mountPoint,
+                       bool ro, bool remount, bool executable,
+                       int ownerUid, int ownerGid, int permMask, bool createLost)
+{
+	int rc;
+    const char *args[11];
+    char mountData[255];
+
+    ALOGE("Exfat::doMount");
+    sprintf(mountData,
+            "locale=utf8,uid=%d,gid=%d,fmask=%o,dmask=%o,noatime,nodiratime",
+            ownerUid, ownerGid, permMask, permMask);
+
+    args[0] = MOUNT_EXFAT_PATH;
+    args[1] = fsPath;
+    args[2] = mountPoint;
+    args[3] = "-o";
+    args[4] = mountData;
+    args[5] = NULL;
+    rc = logwrap(5, args, 1);
+	if( rc !=0 )
+	{
+		ALOGE("Exfat::doMount error :", strerror(errno));
+	}
+
+    return rc;	
+}
+
+int Exfat::format(const char *fsPath, unsigned int numSectors)
+{
+	ALOGW("donnot support exfat format");
+	return 0;
+}
diff --git a/system/vold/exFat.h b/system/vold/exFat.h
--- a/system/vold/exFat.h
+++ b/system/vold/exFat.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _EXFAT_H
+#define _EXFAT_H
+
+#include <unistd.h>
+
+class exFat {
+public:
+    static int check(const char *fsPath);
+    static int doMount(const char *fsPath, const char *mountPoint,
+                       bool ro, bool remount, bool executable,
+                       int ownerUid, int ownerGid, int permMask,
+                       bool createLost);
+    static int format(const char *fsPath, unsigned int numSectors);
+};
+
+#endif
diff --git a/system/vold/Ntfs.cpp b/system/vold/Ntfs.cpp
--- a/system/vold/Ntfs.cpp
+++ b/system/vold/Ntfs.cpp
@@ -38,51 +38,60 @@
 #include "Ntfs.h"

+static char FSCK_NTFS3G_PATH[]   ="/system/bin/ntfs-3g.probe";
+static char MOUNT_NTFS3G_PATH[] ="/system/bin/ntfs-3g";
+
 extern "C" int logwrap(int argc, const char **argv, int background);
 extern "C" int mount(const char *, const char *, const char *, unsigned long, const void *)

 int Ntfs::check(const char *fsPath) {
-
-    // no NTFS file system check is performed, always return true
-    SLOGI("Ntfs filesystem: Skipping fs checks\n");
-    return 0;
+    ALOGV("Ntfs::check");
+  const char *args[4];
+	int rc;
+
+	if (access(FSCK_NTFS3G_PATH, X_OK)) {
+        ALOGW("Skipping fs checks\n");
+        return 0;
+    }
+
+	/* we first mount it read and write*/
+    args[0] = FSCK_NTFS3G_PATH;
+    args[1] = "--readwrite";        
+    args[2] = fsPath;
+    args[3] = NULL;
+
+    rc = logwrap(3, args, 1);
+	if( (rc != 0) && (rc !=15) )
+	{	
+       ALOGE("Filesystem check failed (unknown exit code %d)", rc);
+	   return -1;
+    }

+    return 0;
 }

 int Ntfs::doMount(const char *fsPath, const char *mountPoint,
                 bool ro, bool remount, bool executable,
                 int ownerUid, int ownerGid, int permMask, bool createLost) {
+#if 0
    int rc;
    unsigned long flags;
    char mountData[255];

-    flags = MS_NODEV | MS_NOSUID | MS_DIRSYNC;
+ //  flags = MS_NODEV | MS_NOSUID | MS_DIRSYNC;
+  flags = MS_NODEV | MS_NOSUID ;//| MS_DIRSYNC;

    flags |= (executable ? 0 : MS_NOEXEC);
    flags |= (ro ? MS_RDONLY : 0);
    flags |= (remount ? MS_REMOUNT : 0);

-    // Testing/security, mount ro up to now
-    flags |= MS_RDONLY;
-
-    /*
-     * Note: This is a temporary hack. If the sampling profiler is enabled,
-     * we make the SD card world-writable so any process can write snapshots.
-     *
-     * TODO: Remove this code once we have a drop box in system_server.
-     */
-    char value[PROPERTY_VALUE_MAX];
-    property_get("persist.sampling_profiler", value, "");
-    if (value[0] == '1') {
-        SLOGW("The SD card is world-writable because the"
-            " 'persist.sampling_profiler' system property is set to '1'.");
        permMask = 0;
-    }

    sprintf(mountData,
-            "uid=%d,gid=%d,fmask=%o,dmask=%o",
+            "nls=utf8,uid=%d,gid=%d,fmask=%o,dmask=%o",
            ownerUid, ownerGid, permMask, permMask);
-
+            
+    SLOGE("[lkj]:mount flags %s, mountData %s\n",flags, mountData, );
    rc = mount(fsPath, mountPoint, "ntfs", flags, mountData);

    if (rc && errno == EROFS) {
@@ -90,14 +99,30 @@
        flags |= MS_RDONLY;
        rc = mount(fsPath, mountPoint, "ntfs", flags, mountData);
    }
+    return rc;
+#else
+    int rc;
+    const char *args[11];
+    char mountData[255];
+
+    sprintf(mountData,
+            "locale=utf8,uid=%d,gid=%d,fmask=%o,dmask=%o,noatime,nodiratime",
+            ownerUid, ownerGid, permMask, permMask);
+
+    args[0] = MOUNT_NTFS3G_PATH;
+    args[1] = fsPath;
+    args[2] = mountPoint;
+    args[3] = "-o";
+    args[4] = mountData;
+    args[5] = NULL;
+    rc = logwrap(5, args, 1);

    return rc;
+#endif
+
 }

 int Ntfs::format(const char *fsPath, unsigned int numSectors) {
-
-    SLOGE("Format ntfs filesystem not supported\n");
-    errno = EIO;
-    return -1;
-
+    ALOGW("[lkj]:Skipping ntfs format\n");
+    return 0;
 }
diff --git a/system/vold/Volume.cpp b/system/vold/Volume.cpp
--- a/system/vold/Volume.cpp
+++ b/system/vold/Volume.cpp
@@ -45,6 +45,7 @@
 #include "ResponseCode.h"
 #include "Fat.h"
 #include "Ntfs.h"
+#include "exFat.h"
 #include "Process.h"
 #include "cryptfs.h"

@@ -440,7 +441,7 @@
         errno = 0;
         setState(Volume::State_Checking);
-
+#if 0
        bool isFatFs = true;
        if (Fat::check(devicePath)) {
            if (errno == ENODATA) {
@@ -454,7 +455,7 @@
                return -1;
            }
        }
-
+#endif
         /*
          * Mount the device on our internal staging mountpoint so we can
          * muck with it before exposing it to non priviledged users.
@@ -466,19 +467,36 @@
         // prevented users from writing to it. We don't want that.
         gid = AID_SDCARD_RW;

-        if (isFatFs) {
-            if (Fat::doMount(devicePath, "/mnt/secure/staging", false, false, false,
-                    AID_SYSTEM, gid, 0702, true)) {
-                SLOGE("%s failed to mount via VFAT (%s)\n", devicePath, strerror(errno));
-                continue;
-            }
-        } else {
-            if (Ntfs::doMount(devicePath, "/mnt/secure/staging", false, false, false,
-                    AID_SYSTEM, gid, 0702, true)) {
-                SLOGE("%s failed to mount via NTFS (%s)\n", devicePath, strerror(errno));
-                continue;
-            }
-        }
+        if( !Exfat::check(devicePath) )
+              {
+                  if( Exfat::doMount(devicePath, "/mnt/secure/staging", false, false, false, AID_SYSTEM, gid, 0702, true) )
+                  {
+                        SLOGE("%s failed to mount via ExFat (%s)\n", devicePath, strerror(errno));
+                        continue;
+                  }
+            }
+      else if( !Fat::check(devicePath))
+            {
+                 if( Fat::doMount(devicePath, "/mnt/secure/staging", false, false, false, AID_SYSTEM, gid, 0702, true) )
+                 {
+                      SLOGE("%s failed to mount via VFAT (%s)\n", devicePath, strerror(errno));
+                      continue;
+                 }
+            }
+      else if( !Ntfs::check(devicePath))
+            {
+                  if( Ntfs::doMount(devicePath, "/mnt/secure/staging", false, false, false, AID_SYSTEM, gid, 0702, true) )
+                  {
+                        SLOGE("%s failed to mount via NTFS (%s)\n", devicePath, strerror(errno));
+                        continue;
+                  }
+            }
+      else
+            {
+                  SLOGE("%s failed FS checks (%s)", devicePath, strerror(errno));
+                  setState(Volume::State_Idle);
+                  continue;
+      }

         SLOGI("Device %s, target %s mounted @ /mnt/secure/staging", devicePath, getMountpoint());

         protectFromAutorunStupidity();
